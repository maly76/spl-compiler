package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken){
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

non terminal Program program;
non terminal List<GlobalDeclaration> glob_dec_list;
non terminal GlobalDeclaration glob_dec;
non terminal var_dec_list;

non terminal intlit;

non terminal type;

non terminal gvar_dec;
non terminal proc_dec;

non terminal par_dec_list;
non terminal non_empty_par_dec_list;
//non terminal ref_dec;
non terminal par_dec;

non terminal asgn_dec;

non terminal var;
non terminal var_dec;
non terminal stm_list;

non terminal stm;

non terminal com_operator;
non terminal exp;

non terminal add_exp;
non terminal mul_exp;
non terminal unary_exp;
non terminal primary_exp;

non terminal if_stm;
non terminal call_stm;

non terminal while_stm;

non terminal trans_dec_list;
non terminal non_empty_trans_dec_list;
non terminal trans_dec;

start with program;
program ::= glob_dec_list;
glob_dec_list ::= /* empty */| glob_dec: gdec glob_dec_list: gdeclist;
glob_dec ::=  gvar_dec | proc_dec;

//array ::= ARRAY:a brackdefinitionlist:brackdl OF array:ar {: RESULT = new ArrayTypeExpression(new Position(aleft, aright), brackdl, ar);:}| ARRAY:a brackdefinitionlist:brackdl OF IDENT:i {: RESULT = new ArrayTypeExpression(new Position(aleft, aright), brackdl, i);:};
//array_asgn_dec ::= var ASGN exp SEMIC;

type ::= IDENT | ARRAY:a LBRACK INTLIT:i RBRACK OF type:t;

gvar_dec ::= TYPE:t IDENT:i EQ :te SEMIC;

proc_dec ::= PROC IDENT:i LPAREN par_dec_list: par_dlist RPAREN LCURL var_dec_list: var_list stm_list: stmlist RCURL; // bearbeiten!!!

par_dec_list ::=  /* empty */ | non_empty_par_dec_list:nep;

non_empty_par_dec_list	::= par_dec: par_decd |
par_dec: par_decd COMMA non_empty_par_dec_list: par_list;

//ref_dec ::= REF IDENT COLON type {:RESULT = new P:};
par_dec ::= IDENT:i COLON type:ty |
 REF IDENT:i COLON type:ty ;

asgn_dec ::= var: v ASGN exp: ex SEMIC;

var ::= IDENT: i |
        var:v LBRACK exp:e RBRACK;

intlit ::= INTLIT: i;

var_dec ::= VAR IDENT: i COLON type: ty SEMIC;

var_dec_list ::= /*empty*/ | var_dec:VD var_dec_list:VDL ;

stm_list ::= /* empty */ | stm: stm_d stm_list: stm_list;

stm  ::= asgn_dec: AD | if_stm: IS  | call_stm: CS |
while_stm: WS | LCURL stm: S RCURL |
SEMIC: i ;

com_operator ::= LT  | LE |
GT | GE |
NE | EQ ;

exp ::= add_exp: i |
add_exp:LO com_operator:O add_exp:RO;

add_exp	::= mul_exp:ME | add_exp:LO PLUS mul_exp:RO|
            add_exp:LO MINUS mul_exp:RO;
mul_exp ::= unary_exp:UE | mul_exp:LO STAR unary_exp:RO |
            mul_exp:LO SLASH unary_exp:RO;
unary_exp ::= primary_exp:PE | PLUS unary_exp| MINUS unary_exp;
primary_exp ::=  LPAREN exp:i RPAREN | intlit: i |
var: i ;

/*arg_list ::= *//* empty *//* {:RESULT = List.nil();:} | non_empty_arg_list: neAL {:RESULT = neAL;:};
non_empty_arg_list ::= exp: ex {:RESULT = List.cons(ex, List.nil());:} | exp: ex COMMA non_empty_arg_list: neAL {:RESULT = List.cons(ex, neAL);:} |
IDENT LPAREN arg_list: i RPAREN {:RESULT = i;:};*/

if_stm ::= IF:i LPAREN exp:cond RPAREN stm:stm_listd |
IF:i LPAREN exp:cond RPAREN stm:stm_listd ELSE stm:elsepart;

call_stm ::= IDENT: i LPAREN trans_dec_list: arg_list RPAREN SEMIC;

while_stm ::= WHILE:w LPAREN exp:con RPAREN stm:stm_list ;

trans_dec_list ::=  /* empty */ | non_empty_trans_dec_list: TL;
non_empty_trans_dec_list ::= trans_dec: TD |
trans_dec: TD COMMA non_empty_trans_dec_list: TDL |
IDENT LPAREN non_empty_trans_dec_list: i RPAREN ;

trans_dec ::= exp: ex;

-------------------------------------------------------------222222222---------------------------------------------

package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken){
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

non terminal Program program;
non terminal List<GlobalDeclaration> glob_dec_list;
non terminal GlobalDeclaration glob_dec;
non terminal var_dec_list;

non terminal intlit;

non terminal type;

non terminal gvar_dec;
non terminal proc_dec;

non terminal par_dec_list;
non terminal non_empty_par_dec_list;
//non terminal ref_dec;
non terminal par_dec;

non terminal asgn_dec;

non terminal var;
non terminal var_dec;

non terminal stm_list;
non terminal comp_stm;

non terminal stm;

non terminal com_operator;
non terminal exp;

non terminal add_exp;
non terminal mul_exp;
non terminal unary_exp;
non terminal primary_exp;

non terminal if_stm;
non terminal call_stm;

non terminal while_stm;

non terminal trans_dec_list;
non terminal non_empty_trans_dec_list;
non terminal trans_dec;

start with program;
program ::= glob_dec_list;
glob_dec_list ::= /* empty */| glob_dec glob_dec_list;
glob_dec ::=  gvar_dec | proc_dec;

//array ::= ARRAY:a brackdefinitionlist:brackdl OF array:ar {: RESULT = new ArrayTypeExpression(new Position(aleft, aright), brackdl, ar);:}| ARRAY:a brackdefinitionlist:brackdl OF IDENT:i {: RESULT = new ArrayTypeExpression(new Position(aleft, aright), brackdl, i);:};
//array_asgn_dec ::= var ASGN exp SEMIC;

type ::= IDENT | ARRAY LBRACK INTLIT RBRACK OF type;

gvar_dec ::= TYPE IDENT EQ type SEMIC | VAR IDENT COLON type SEMIC;

proc_dec ::= PROC IDENT LPAREN par_dec_list RPAREN LCURL var_dec_list stm_list RCURL; // bearbeiten!!!

par_dec_list ::=  /* empty */ | non_empty_par_dec_list;

non_empty_par_dec_list	::= par_dec |
par_dec COMMA non_empty_par_dec_list;

//ref_dec ::= REF IDENT COLON type {:RESULT = new P:};
par_dec ::= IDENT COLON type |
 REF IDENT COLON type ;

asgn_dec ::= var ASGN exp SEMIC;

var ::= IDENT |
        var LBRACK exp RBRACK;

intlit ::= INTLIT;

var_dec ::= VAR IDENT COLON type SEMIC;

var_dec_list ::= /*empty*/ | var_dec var_dec_list;

comp_stm ::= stm_list;

stm_list ::= /* empty */ | stm stm_list;

stm  ::= asgn_dec | if_stm | call_stm |
while_stm | LCURL comp_stm RCURL |
SEMIC;

com_operator ::= LT  | LE |
GT | GE |
NE | EQ ;

exp ::= add_exp |
add_exp com_operator add_exp;

add_exp	::= mul_exp | add_exp PLUS mul_exp|
            add_exp MINUS mul_exp;
mul_exp ::= unary_exp | mul_exp STAR unary_exp |
            mul_exp SLASH unary_exp;
unary_exp ::= primary_exp | PLUS unary_exp| MINUS unary_exp;
primary_exp ::=  LPAREN exp RPAREN | intlit |
var ;

/*arg_list ::= *//* empty *//* {:RESULT = List.nil();:} | non_empty_arg_list: neAL {:RESULT = neAL;:};
non_empty_arg_list ::= exp: ex {:RESULT = List.cons(ex, List.nil());:} | exp: ex COMMA non_empty_arg_list: neAL {:RESULT = List.cons(ex, neAL);:} |
IDENT LPAREN arg_list: i RPAREN {:RESULT = i;:};*/

if_stm ::= IF LPAREN exp RPAREN stm |
IF LPAREN exp RPAREN stm ELSE stm;

call_stm ::= IDENT LPAREN trans_dec_list RPAREN SEMIC;

while_stm ::= WHILE LPAREN exp RPAREN stm ;

trans_dec_list ::=  /* empty */ | non_empty_trans_dec_list;
non_empty_trans_dec_list ::= trans_dec |
trans_dec COMMA non_empty_trans_dec_list |
IDENT LPAREN non_empty_trans_dec_list RPAREN ;

trans_dec ::= exp;